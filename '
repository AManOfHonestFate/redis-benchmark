package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/redis/go-redis/v9"
)

type Statistics struct {
	TCPConnections int64
	TotalTasks     atomic.Int64
	ErrorCounter   atomic.Int64
	LatencySum     time.Duration
	TestDuration   time.Duration
	mu             sync.Mutex
}

func (s *Statistics) Display() string {
	return fmt.Sprintf("\n- total tasks: %d\n- average latency: %s\n- errors: %d\n- total connections: %d\n- time: %s\n",
		s.TotalTasks.Load(), s.LatencySum/time.Duration(s.TotalTasks.Load()), s.ErrorCounter.Load(), s.TCPConnections, s.TestDuration)
}

func SetupContiniousKeys(rdb *redis.Client, slots int) {
	ctx, cansel := context.WithTimeout(context.Background(), time.Second)
	for i := range slots {
		_, err := rdb.Set(ctx, strconv.Itoa(i), i, 0).Result()
		if err != nil {
			cansel()
			log.Fatal("initial set failed", err)
		}
	}
	cansel()
}

func scenarioRunBasic(tasks int64, workers int, stats *Statistics, do func(*rand.Rand) (time.Duration, error)) {
	wg := sync.WaitGroup{}
	startTime := time.Now()

	for i := range workers {
		wg.Add(1)

		go func() {
			seed := rand.New(rand.NewSource(int64(i)))
			defer wg.Done()

			for range tasks {
				latency, err := do(seed)
				if err != nil {
					stats.ErrorCounter.Add(1)
				}

				stats.mu.Lock()
				stats.LatencySum += latency
				stats.mu.Unlock()
			}
		}()
	}

	wg.Wait()

	endTime := time.Now()
	stats.TestDuration = endTime.Sub(startTime)
	stats.TotalTasks.Add(tasks*int64(workers) - stats.ErrorCounter.Load())
}

func generateTask(generator *rand.Rand, numberOfSlots int) int {
	return generator.Intn(numberOfSlots)
}

type RandomSetsScenario struct {
	NumberOfSlots int
	Name          string
}

func (s *RandomSetsScenario) GetName() string {
	return s.Name
}

func (s *RandomSetsScenario) Run(ctx context.Context, rdb *redis.ClusterClient, tasks int64, workers int) *Statistics {
	stats := Statistics{}

	scenarioRunBasic(tasks, workers, &stats, func(seed *rand.Rand) (time.Duration, error) {
		task := s.generateTask(seed)

		requestStart := time.Now()
		_, err := rdb.Set(ctx, strconv.Itoa(task), task, 0).Result()
		latency := time.Since(requestStart)

		return latency, err
	})

	return &stats
}

func (s *RandomSetsScenario) generateTask(generator *rand.Rand) int {
	return generator.Intn(s.NumberOfSlots)
}

type RandomReadsScenario struct {
	NumberOfSlots int
	Name          string
}

func (s *RandomReadsScenario) GetName() string {
	return s.Name
}

func (s *RandomReadsScenario) Run(ctx context.Context, rdb *redis.ClusterClient, tasks int64, workers int) *Statistics {
	stats := Statistics{}

	scenarioRunBasic(tasks, workers, &stats, func(seed *rand.Rand) (time.Duration, error) {
		task := generateTask(seed, s.NumberOfSlots)

		requestStart := time.Now()
		_, err := rdb.Get(ctx, strconv.Itoa(task)).Result()
		latency := time.Since(requestStart)

		return latency, err
	})

	return &stats
}

type RandomReadSetScenario struct {
	NumberOfSlots int
	Name          string
}

func (s *RandomReadSetScenario) GetName() string {
	return s.Name
}

func (s *RandomReadSetScenario) Run(ctx context.Context, rdb *redis.ClusterClient, tasks int64, workers int) *Statistics {
	stats := Statistics{}

	scenarioRunBasic(tasks, workers, &stats, func(seed *rand.Rand) (time.Duration, error) {
		task := generateTask(seed, s.NumberOfSlots)

		var err error
		requestStart := time.Now()
		if seed.Intn(2) == 0 {
			_, err = rdb.Get(ctx, strconv.Itoa(task)).Result()
		} else {
			_, err = rdb.Set(ctx, strconv.Itoa(task), task, 0).Result()
		}
		latency := time.Since(requestStart)

		return latency, err
	})

	return &stats
}

type PipelineScenario struct {
	NumberOfSlots int
	PipelineSize  int
	Name          string
}

func (s *PipelineScenario) GetName() string {
	return s.Name
}

func (s *PipelineScenario) Run(ctx context.Context, rdb *redis.ClusterClient, tasks int64, workers int) *Statistics {
	stats := Statistics{}

	scenarioRunBasic(tasks/int64(s.PipelineSize), workers, &stats, func(seed *rand.Rand) (time.Duration, error) {
		pipeline := rdb.Pipeline()
		for range s.PipelineSize {
			task := generateTask(seed, s.NumberOfSlots)
			var err error
			requestStart := time.Now()
			if seed.Intn(2) == 0 {
				_, err = rdb.Get(ctx, strconv.Itoa(task)).Result()
			} else {
				_, err = rdb.Set(ctx, strconv.Itoa(task), task, 0).Result()
			}
			latency := time.Since(requestStart)
		}
	})

	return &stats
}
